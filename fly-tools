#!/usr/bin/env bash
#
# fly-tools â”€ modular helper for the â€œpoetristâ€ Fly app
# --------------------------------------------
# USAGE:
#   ./fly-tools all         # run every step
#   ./fly-tools check-secret
#   ./fly-tools pull-db
#   ./fly-tools restore-db
#   ./fly-tools compress-db
#   ./fly-tools deploy
#   ./fly-tools token
#   ./fly-tools help

set -euo pipefail

# â”€â”€â”€â”€â”€ constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
APP="poetrist"
REMOTE_DB="/app/poetrist/blog.sqlite3"

LOCAL_DB="poetrist/blog.sqlite3.backup"     # backup copy pulled from Fly
RESTORED_DB="${LOCAL_DB%}"                 # â†’ poetrist/blog.sqlite3
TMP_DB="${LOCAL_DB}.remote"                # temp file during sftp download

SECRET_FILE="poetrist/.secret_key"

# â”€â”€â”€â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
hash_db() {
  local file="$1"

  # 1) Local file?  â†’ quick, no network hop
  if [[ -f "$file" ]]; then
    sha256sum "$file" | awk '{print $1}'
    return 0
  fi

  # 2) Remote path (inside Fly VM) â€“ ask the VM to hash it.
  fly ssh console -q -a "$APP" -C \
    "sha256sum $file" | awk '{print $1}'
}


# â”€â”€â”€â”€â”€ functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
usage() { cat <<EOF
fly-tools â€“ modular Fly helper for â€œ${APP}â€

Sub-commands:
  check-secret   Ensure .secret_key exists locally
  pull-db        Download blog.sqlite3 from production (only if changed)
  restore-db     Restore local blog.sqlite3 from backup
  deploy         fly deploy (build + release)
  token          Rotate one-time login token & print login URL
  all            Perform every step (check-secret â†’ pull-db â†’ deploy â†’ token)
  help           Show this message
EOF
}

check_secret() {
  if [[ -f "$SECRET_FILE" ]]; then return 0; fi
  echo "â•  Creating missing .secret_key"
  mkdir -p "$(dirname "$SECRET_FILE")"
  openssl rand -hex 32 > "$SECRET_FILE"
}

pull_db() {
  echo "â¬‡ï¸   Checking if remote database changedâ€¦"

  local remote_hash local_hash
  remote_hash=$(hash_db "$REMOTE_DB") || true
  local_hash=$(hash_db "$LOCAL_DB")   || true

  if [[ -z "$remote_hash" ]]; then
    echo "    âš ï¸  Could not read remote DB hash â€“ downloading anyway."
  elif [[ "$remote_hash" == "$local_hash" ]]; then
    echo "    âœ…  Remote DB identical to local backup â€“ skipping download."
    return 0
  else
    echo "    ğŸ”„  Hashes differ â€“ downloading new copyâ€¦"
  fi

  if fly ssh sftp get "$REMOTE_DB" "$TMP_DB" -a "$APP" 2>/dev/null; then
    mv -f "$TMP_DB" "$LOCAL_DB"
    echo "    pulled â†’ $LOCAL_DB"
  else
    echo "    âŒ  No remote DB found â€“ continuing"
    rm -f "$TMP_DB" || true
  fi
}

restore_db() {
  # copy poetrist/blog.sqlite3.backup â†’ poetrist/blog.sqlite3
  local target="${LOCAL_DB%.backup}"   # strips the â€œ.backupâ€ suffix
  echo "â™»ï¸   Restoring database from backupâ€¦"
  if [[ -f "$LOCAL_DB" ]]; then
    cp -f "$LOCAL_DB" "$target"
    echo "    copied $LOCAL_DB â†’ $target"
  else
    echo "    backup not found: $LOCAL_DB"
    return 1
  fi
}

compress_db() {
  if [[ ! -f "$RESTORED_DB" ]]; then
    echo "    local DB not found: $RESTORED_DB"
    return 1
  fi

  echo "ğŸ—œï¸   Optimising & vacuuming $RESTORED_DB â€¦"
  .venv/bin/python - <<PY
import sqlite3, pathlib
db_path = pathlib.Path("$RESTORED_DB")
con = sqlite3.connect(db_path)
try:
    # 1) merge & compress all FTS5 segments
    con.execute("INSERT INTO entry_fts(entry_fts) VALUES('optimize')")
    con.commit()
    # 2) reclaim free pages
    con.isolation_level = None  # autocommit ON for VACUUM
    con.execute("VACUUM")
finally:
    con.close()
print("    optimisation complete.")
PY
}

deploy_app() {
  echo "ğŸš€  fly deploy"
  fly deploy -a "$APP"
}

rotate_token() {
  echo "ğŸ”‘  Rotating one-time login tokenâ€¦"
  local token
  token=$(
    fly ssh console -a "$APP" -C \
      '/app/.venv/bin/flask --app poetrist/blog.py token' |
    grep -Eo '^[A-Za-z0-9._-]{20,}$' | head -n1
  )
  echo
  echo "One-time token (1 minute) â†’"
  echo "$token"
}

# â”€â”€â”€â”€â”€ dispatcher â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
cmd="${1:-help}"
case "$cmd" in
  check-secret)  check_secret ;;
  pull-db)       pull_db ;;
  restore-db)    restore_db ;;
  compress-db)   compress_db ;;
  deploy)        deploy_app ;;
  token)         rotate_token ;;
  all)           check_secret && pull_db && compress_db && restore_db && deploy_app && rotate_token ;;
  help|-h|--help) usage ;;
  *) echo "Unknown sub-command: $cmd"; echo; usage; exit 1 ;;
esac
